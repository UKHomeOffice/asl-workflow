#!/usr/bin/env node
try {
  // eslint-disable-next-line
  require('dotenv/config');
} catch (e) {
  // ignore
}

const { get } = require('lodash');
const Taskflow = require('@ukhomeoffice/taskflow');
const schema = require('@asl/schema');
const settings = require('../config');

const logProfileMerges = async () => {
  const { Task } = Taskflow({ db: settings.taskflowDB });
  const { Profile, ProfileMergeLog, transaction } = schema(settings.db);
  const trx = await transaction();

  try {
    const previousMerges = await ProfileMergeLog.query(trx).select('taskId').whereNotNull('taskId');

    const taskQuery = Task.query()
      .where({ status: 'autoresolved' })
      .whereJsonSupersetOf('data', { model: 'profile', action: 'merge' });

    if (previousMerges.length > 0) {
      console.log(`Found ${previousMerges.length} profile merge logs, excluding them from this run`);
      const taskIds = previousMerges.map(l => l.taskId);
      taskQuery.whereNotIn('id', taskIds);
    }

    const tasks = await taskQuery;

    console.log(`Found ${tasks.length} profile merge tasks`);

    for (const task of tasks) {
      const fromProfile = await Profile.query(trx).findById(get(task, 'data.subject'));
      const toProfile = await Profile.query(trx).findById(get(task, 'data.data.target'));

      if (!fromProfile || !toProfile) {
        continue;
      }

      const mergeTime = task.updatedAt.toISOString();

      console.log(`Profile ${fromProfile.id} was merged into ${toProfile.id} at ${mergeTime}`);

      await ProfileMergeLog.query(trx).insert({
        taskId: task.id,
        fromProfileId: fromProfile.id,
        toProfileId: toProfile.id,
        createdAt: mergeTime,
        updatedAt: mergeTime
      });
    }

    await trx.commit();
    console.log('Profile merge log complete.');
  } catch (e) {
    await trx.rollback();
    throw e;
  }
};

Promise.resolve()
  .then(() => logProfileMerges())
  .then(() => process.exit())
  .catch(err => {
    console.error(err.stack);
    process.exit(1);
  });
